
// INUTILISE DANS LA VERSION FINALE
// c'était la version où on disait aux goroutines combien de jobs traiter avant de finir


package main

import (
	"fmt"
	"time"
)

var (
	NOMBRE_GOROUTINES = 16
)

type portionTodo struct {
	positionY int
	matriceB *[][]float64 //on a besoin de toutes les colonnes de B pour calculer 1 ligne de la mat produit
	ligneYmatriceA *[]float64 //sera parcourue à chaque colonne X de B
}

type portionFinished struct {
	positionY int
	ligneFinale *[]float64 //la ligne Y remplie de la matrice produit
}

func multiplicationTotale(matriceA [][]float64, matriceB [][]float64) [][]float64{
	//récupérer tailles (vérifié dans input : tailleAx==tailleBy)
	tailleAy := len(matriceA)
	tailleBx := len(matriceB[0])
	tailleCommune := len(matriceB)

	//créer et remplir matrice résultat C
	matriceC := make([][]float64, tailleAy)
	for y:= 0; y<tailleAy;y++ {
		ligne := make([]float64, tailleBx)
		for x := 0; x<tailleBx; x++ {
			for i := 0; i<tailleCommune; i++ {
				ligne[x] += matriceA[y][i]*matriceB[i][x]
			}
		}
		matriceC[y] = ligne
	}

	return matriceC

}

//calcule 1 ligne de la matrice produit par tour
func workerMultiplicationPartielle(nombre_travaux int, jobs chan *portionTodo, result chan *portionFinished){
	compteur := nombre_travaux
	for compteur>0{
		//récupération des infos du channel
		job :=<- jobs
		tailleRecurrente := len(*job.ligneYmatriceA)
		nombreColonnes := len((*job.matriceB)[0])

		//partie calcul
		ligne := make([]float64, nombreColonnes)
		for x:=0; x<nombreColonnes; x++{
			ligne[x] = 0
			for i:=0; i<tailleRecurrente; i++ {
				ligne[i] += (*job.ligneYmatriceA)[i] * (*job.matriceB)[i][x]
			}
		}

		//rendu du travail effectué
		rendu := portionFinished{positionY: job.positionY}
		rendu.ligneFinale = &ligne
		result <- &rendu
	}
}

func managerMultiplicationPartielle(matriceA [][]float64, matriceB [][]float64) [][]float64{
	nombre_total_workers := NOMBRE_GOROUTINES
	nombre_total_travaux := len(matriceA)
	matriceC := make([][]float64, nombre_total_travaux)

	jobsChannel := make(chan *portionTodo, nombre_total_travaux)
	resultChannel := make(chan *portionFinished, nombre_total_travaux)


	//répartir le plus possible le nombre de lignes à traiter entre les workers
	nombre_workers_zeleux := nombre_total_travaux % nombre_total_workers //travaillent 1 job de plus que paresseux (reste)
	nombre_workers_paresseux := nombre_total_workers - nombre_workers_zeleux
	nombre_travaux_par_worker_zeleux := nombre_total_travaux / nombre_total_workers + 1 //non nul même si aucun zéleux... pas problématique puisque ignorés dans ce cas
	nombre_travaux_par_worker_paresseux := nombre_total_travaux / nombre_total_workers
	for i:=0; i<nombre_workers_zeleux; i++ {
		go workerMultiplicationPartielle(nombre_travaux_par_worker_zeleux, jobsChannel, resultChannel)
	}
	for i:=0; i<nombre_workers_paresseux; i++{
		go workerMultiplicationPartielle(nombre_travaux_par_worker_paresseux, jobsChannel, resultChannel)
	}

	go func(){
		for i:=0; i<nombre_total_travaux; i++ {
			var portion portionTodo
			portion = portionTodo{positionY: i, matriceB: &matriceB, ligneYmatriceA: &(matriceA[i])}
			jobsChannel <- &portion
			//close(jobsChannel)
		}
	}()

	for i:=0; i<nombre_total_travaux; i++ {
		resultat :=<- resultChannel
		pos := resultat.positionY
		matriceC[pos] = *resultat.ligneFinale
	}

	return matriceC
}

func multiplication(){
	fmt.Println("Test")

	tailleAx:=250
	tailleAy:=250
	tailleBx:=250
	tailleBy:=250

	matriceA := make([][]float64, tailleAy)
	matriceB := make([][]float64, tailleBy)

	//matrice A
	for y:= 0; y<tailleAy;y++ {
		ligne := make([]float64, tailleAx)
		for x := 0; x<tailleAx; x++ {
			if x==y {
				ligne[x] = 1
			} else {
				ligne[x] = 0
			}
		}
		matriceA[y] = ligne
	}

	//matrice B
	for y:= 0; y<tailleAy;y++ {
		ligne := make([]float64, tailleBx)
		for x := 0; x<tailleBx; x++ {
			if x==y {
				ligne[x] = 1
			} else {
				ligne[x] = 0
			}
		}
		matriceB[y] = ligne
	}

	//test 1 thread
	start1 := time.Now()
	fmt.Println(multiplicationTotale(matriceA, matriceB))
	end1 := time.Now()
	fmt.Println("Durée du calcul 1 thread :",end1.Sub(start1))

	//test parallélisme
	start2 := time.Now()
	fmt.Println(managerMultiplicationPartielle(matriceA, matriceB))
	end2 := time.Now()
	fmt.Println("Durée du calcul 1 thread :",end1.Sub(start1))
	fmt.Println("Durée du calcul avec goroutines :",end2.Sub(start2))


}

